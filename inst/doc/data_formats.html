<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Data formats</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Data formats</h1>



<p>The NeuroDecodeR (NDR) uses two very similar data formats called
<code>raster format</code> and <code>binned format</code>. For almost
all analysis, one starts by saving data from each site in
<code>raster format</code>. One then converts the data to
<code>binned format</code> using the <code>create_binned_data()</code>
which has the data from all the sites in a single data frame at a
coarser temporal resolution that is stored in a single file. The
<code>binned format</code> data is then used in all subsequent decoding
analyses. More information about what is required to have data in these
specified formats is described below.</p>
<div id="raster-format" class="section level2">
<h2>Raster format</h2>
<p>Raster format data contains the data at the highest temporal
resolution. For raster data, there is a separate file that contains a
data frame of data each site (e.g., for electrophysiology experiments
there is a separate file for each single neuron, for EEG experiments
there is a separate file for each EEG channel, etc.). The reason for
having data from each site in a separate file is to prevent memory from
running out of memory when trying to load data from many sites when the
data is at a high temporal resolution.</p>
<p>For raster format data, the number of rows in the data frame
correspond to the number of trials in the experiment. Data that is in
raster format is a data frame that must contain variables (columns) that
start with the following prefixes:</p>
<ol style="list-style-type: decimal">
<li><p><code>labels.XXX</code> These variables contain labels of which
experimental conditions were shown on a given trial.</p></li>
<li><p><code>time.XXX_YYY</code> These variables contain the data for a
given time, where where XXX is the start time of the data in a
particular bin and YYY is the end time. The time interval should be
specified such in the form [XXX, YYY), so that the start time is a
closed interval and the end time is an open interval. Thus, for data
that is recording continuously, the value YYY of one bin, would be equal
to the value XXX for the next bin (e.g., <code>time.100_101</code>,
<code>time.101_102</code>, <code>time.102_103</code>, etc.).</p></li>
</ol>
<p>There can also be two additional optional variables in a raster
format data frame which are:</p>
<ol start="3" style="list-style-type: decimal">
<li><p><code>site_info.XXX</code> These variables contain additional
meta data about the site. For example, one could have a variable called
<code>site_info.brain_area</code> which indicates which brain region a
given site came from. All rows for a given <code>site_info.XXX</code>
variable typically have the same value.</p></li>
<li><p><code>trial_number</code> This variable specifies a unique number
for each row indicating which trial a given row of data came from. This
is useful for data where all sites were recorded simultaneously in order
to allow one to do the decoding on actual simultaneously recorded data
(e.g., by using the <code>ds_basic()</code>
<code>create_simultaneously_recorded_populations</code>
argument).</p></li>
</ol>
<p>The class attribute for data in raster format should be set to
<code>attr(raster_data, &quot;class&quot;) &lt;- c(&quot;raster_data&quot;, &quot;data.frame&quot;)</code>.
This will enable the plot() function to correctly plot data in raster
format.</p>
<div id="checking-if-data-is-in-valid-raster-format" class="section level3">
<h3>Checking if data is in valid raster format</h3>
<p>To test whether data correctly conforms to the requirements of raster
format, one can use the internal function
<code>NeuroDecodeR:::test_valid_raster_data_format()</code>.</p>
</div>
<div id="example-raster-format-data" class="section level3">
<h3>Example raster-format data</h3>
<p>Below is an example of raster format data file from the <a href="datasets.html">Zhang-Desimone 7 object data set</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>raster_dir_name <span class="ot">&lt;-</span> <span class="fu">file.path</span>(<span class="fu">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="at">package =</span> <span class="st">&quot;NeuroDecodeR&quot;</span>), <span class="st">&quot;Zhang_Desimone_7object_raster_data_small_rda&quot;</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>full_file_name <span class="ot">&lt;-</span> <span class="fu">file.path</span>(raster_dir_name, <span class="st">&quot;bp1001spk_01A_raster_data.rda&quot;</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># test the file is in valid raster format</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>NeuroDecodeR<span class="sc">::</span><span class="fu">test_valid_raster_format</span>(full_file_name)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># load the data to see the variables in it</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(full_file_name)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(raster_data[, <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>])</span></code></pre></div>
<pre><code>##   site_info.session_ID site_info.recording_channel site_info.unit
## 1                 1001                           1              A
## 2                 1001                           1              A
## 3                 1001                           1              A
## 4                 1001                           1              A
## 5                 1001                           1              A
## 6                 1001                           1              A
##   labels.combined_ID_position labels.stimulus_position labels.stimulus_ID
## 1                  hand_upper                    upper               hand
## 2               flower_middle                   middle             flower
## 3               guitar_middle                   middle             guitar
## 4                  face_upper                    upper               face
## 5                 kiwi_middle                   middle               kiwi
## 6                 couch_upper                    upper              couch
##   time.-500_-499 time.-499_-498 time.-498_-497 time.-497_-496
## 1              0              0              0              0
## 2              0              0              0              0
## 3              0              0              0              0
## 4              0              0              0              0
## 5              0              0              0              0
## 6              0              0              0              0</code></pre>
</div>
</div>
<div id="binned-format" class="section level2">
<h2>Binned format</h2>
<p>Binned format data contains data from multiple sites (e.g., data from
many neurons, EEG channels, etc.). Data that is in binned format is very
similar to data that is in raster format except that it contains
information from multiple sites and usually contains the information at
a coarser temporal resolution. For example, binned data would typically
contain firing rates over some time interval sampled at a lower rate, as
opposed to raster format data that would typically contain individual
spikes sampled at a higher rate. Binned format data is typically created
from raster format data using the function
<code>create_binned_data()</code> which converts a directory of raster
format files into a binned-format file that is used in subsequent
decoding analyses.</p>
<p>Binned format data must be in a data frame where the number of rows
in the data frame correspond to the number of trial in all experimental
recording sessions across all sites. The binned format data frame must
also contain the variables that start with the following prefixes:</p>
<ol style="list-style-type: decimal">
<li><p><code>siteID.XXX</code> A unique number indicating a site a given
row of data corresponds to. These are typically automatically generated
by the <code>create_binned_data()</code> function.</p></li>
<li><p><code>labels.XXX</code> These variables contain labels of which
experimental conditions occurred on a given trial. These are typically
copied from the raster data when <code>create_binned_data()</code> is
called.</p></li>
<li><p><code>time.XXX_YYY</code> These variables contain data in a time
range from [XXX, YYY). These values are typically derived from the
raster data <code>time.XXX_YYY</code> values when the
<code>create_binned_data()</code> is called.</p></li>
</ol>
<p>There can also be two additional optional variables in a binned
format data frame which are:</p>
<ol start="4" style="list-style-type: decimal">
<li><p><code>site_info.XXX</code> These variables contain additional
meta data out the site. For example, one could have a variable called
<code>site_info.brain_area</code> which indicated which brain region a
given site came from.</p></li>
<li><p><code>trial_number</code> This is a variable that specifies a
unique for each row indicating which trial a given row of data came
from. This is useful for data where all sites were recorded
simultaneously in order to allow one to do the decoding on actual
simultaneously recorded data (e.g., by using the <code>ds_basic()</code>
<code>create_simultaneously_recorded_populations</code>
argument).</p></li>
</ol>
<div id="checking-if-data-is-in-valid-binned-format" class="section level3">
<h3>Checking if data is in valid binned format</h3>
<p>To test whether data correctly conforms to the requirements of binned
format, one can use the internal function
<code>NeuroDecodeR:::test_valid_binned_data_format()</code>.</p>
</div>
<div id="example-binned-format-data" class="section level3">
<h3>Example binned-format data</h3>
<p>Below is an example of binned format data file from the <a href="datasets.html">Zhang-Desimone 7 object data set</a>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>binned_file_name <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;extdata/ZD_150bins_50sampled.Rda&quot;</span>, <span class="at">package=</span><span class="st">&quot;NeuroDecodeR&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># test the file is in valid binned format using an internal function</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>NeuroDecodeR<span class="sc">:::</span><span class="fu">test_valid_binned_format</span>(binned_file_name)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># load the data to see the variables in it</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(binned_file_name)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(binned_data[, <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>])</span></code></pre></div>
<pre><code>##   siteID site_info.session_ID site_info.recording_channel site_info.unit
## 1      1                 1001                           1              A
## 2      1                 1001                           1              A
## 3      1                 1001                           1              A
## 4      1                 1001                           1              A
## 5      1                 1001                           1              A
## 6      1                 1001                           1              A
##   labels.combined_ID_position labels.stimulus_position labels.stimulus_ID
## 1                  hand_upper                    upper               hand
## 2               flower_middle                   middle             flower
## 3               guitar_middle                   middle             guitar
## 4                  face_upper                    upper               face
## 5                 kiwi_middle                   middle               kiwi
## 6                 couch_upper                    upper              couch
##   time.-500_-350 time.-450_-300 time.-400_-250
## 1    0.006666667    0.013333333    0.020000000
## 2    0.000000000    0.006666667    0.006666667
## 3    0.000000000    0.000000000    0.000000000
## 4    0.000000000    0.000000000    0.000000000
## 5    0.000000000    0.000000000    0.000000000
## 6    0.000000000    0.006666667    0.006666667</code></pre>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
